<!-- Generated by Docile.jl | 2015-09-15T18:48:03 -->

# Package Reference

## Index

  * [`makedocs`](#Docile.Builder.makedocs)
  * [`doctest`](#Docile.Tester.doctest)
  * [`details`](#Docile.Tester.details)
  * [`register!`](#Docile.Hooks.register!)
  * [`Hooks.track`](#Docile.Hooks.track)
  * [`Hooks.@__doc__`](#Docile.Hooks.@__doc__)
  * [`Hooks.__doc__`](#Docile.Hooks.__doc__)
  * [`Hooks.doc!sig`](#Docile.Hooks.doc!sig)
  * [`Hooks.doc!args`](#Docile.Hooks.doc!args)
  * [`Hooks.doc!kwargs`](#Docile.Hooks.doc!kwargs)
  * [`Hooks.directives`](#Docile.Hooks.directives)

## Building Documentation

<a name="Docile.Builder.makedocs"></a>

```
makedocs()
```

Generate markdown documentation from templated files.

**Keyword Arguments:**

`source = "src"`

Directory to collect markdown files from. The provided path is treated as being relative to the directory in which the build script is run.

`build = "build"`

Destination directory for output files. As with `source` the path is relative to the build script's directory.

`clean = false`

Should the build directory be deleted before building? `external` files are not affected by this.

`verbose = true`

Print information about build process to terminal. On by default.

`external = Dict("README.md"=>"../README.md")`

User-defined files that, if found in `source`, will be written to the provided paths rather than the default in `build`. `makedocs` writes `README.md` files to the parent folder by default. This can be disabled by setting `external = Dict()`.

**Usage:**

Import `Docile` and the modules that should be documented. Then call `makedocs` with any additional settings that are needed.

```jl
using Docile, MyModule
makedocs()                   # Without customisations.
makedocs(source = "../docs") # With source folder ``docs``.
makedocs(clean = true)       # Clean build directory before building.
```

## Testing Code Blocks

<a name="Docile.Tester.doctest"></a>

```
doctest(mod; submodules = true)
```

Test all Julia code blocks found in a module's docstrings.

By default all submodules are also checked. This can be disabled by setting the `submodules` keyword to `false`.

`doctest` returns a `Results` object that contains the results of all tests.

See also: `details`.

<a name="Docile.Tester.details"></a>

```
details(results; all = false)
```

Display details of a doctest. Information provided includes:

  * status of the test (either `Passed` or `Failed`)
  * module and object names
  * value returned after evaluating the code block
  * contents of the code block

By default only the failed code blocks will be displayed when calling `details`. To see all the results pass the keyword argument `all = true`.

## Documentation System Hooks

<a name="Docile.Hooks"></a>

```
Docile.Hooks :: Module
```

**Exported Names:**

  * `@__doc__`
  * `__doc__`
  * `directives`
  * `doc!args`
  * `doc!kwargs`
  * `doc!sig`
  * `register!`
  * `track`

<a name="Docile.Hooks.register!"></a>

```
register!(defs...)
```

Add docsystem hooks to be run whenever a docstring is found in the current module. Each hook will be run in the order in which they were registered.

```julia
using Docile

register!(Hooks.directives)
```

### Debugging

<a name="Docile.Hooks.track"></a>

```
track([t])
```

Debugging directive to track the raw values found by the docsystem.

### Documenting Macro-generated Code

<a name="Docile.Hooks.__doc__"></a>

```
__doc__(str, def)
```

Enable `@__doc__` capturing in the docsystem.

<a name="Docile.Hooks.@__doc__"></a>

```
@__doc__(ex)
```

Mark macro-generated expressions that accept documentation.

```julia
macro example(f)
    quote
        @__doc__ $(f)(x)       = 1
                 $(f)(x, y)    = 2
        @__doc__ $(f)(x, y, z) = 3
    end |> esc
end
```

### Implicit Docstring Variables

<a name="Docile.Hooks.doc!sig"></a>

```
doc!sig(str, def)
```

Generate and store the automatic header string for a documented expression in the docstring-local variable `doc!sig`. It can be interpolated into the docstring as with any normal variable.

```julia
using Docile
register!(Hooks.doc!sig)

"
    $doc!sig

...
"
f(x, y) = x + y
```

will produce a docstring containing

```
    f(x,y)

...
```

<a name="Docile.Hooks.doc!args"></a>

```
doc!args(str, def)
```

Capture all documented method arguments and store in the docstring-local variable `doc!args`, which can be spliced into the docstring.

```julia
using Docile
register!(Hooks.doc!args)

"
$doc!args
"
f("...", x) = x
```

will produce a docstring containing

```
**Arguments:**

`x`:

...
```

<a name="Docile.Hooks.doc!kwargs"></a>

```
doc!kwargs(str, def)
```

Capture all documented method keywords and store in the docstring-local variable `doc!kwargs`, which can be spliced into the docstring.

```julia
using Docile
register!(Hooks.doc!kwargs)

"
$doc!kwargs
"
f(; "...", k = 1) = k
```

will produce a docstring containing

```
**Keywords:**

`k=1`:

...
```

### Directives

<a name="Docile.Hooks.directives"></a>

```
directives(str, def)
```

Enable directive syntax in docstrings.

#### Directive Syntax Guide

<a name="Docile.DocTree.DIRECTIVES"></a>

```
@<name>{...}
```

Where `<name>` contains only letters and `...` may contain any text. When no `<name` is provided the default directive, `:docs` is used.

*Available directives:*

```
@{...} or @docs{...}
```

The `:docs` directive replaces it's content with the docstrings of the objects in `...`. Multiple objects may appear within a single `@{...}` and their docstrings are spliced back in order.

```
@esc{...}
```

Allows for writing a directive within a directive so that the inner one is not parsed and expanded. Useful when writing documentation that mentions directives.

`:esc` is used to store all text found between directives in a file or docstring internally.

```
@module{...}
```

Change the current module in which directives are evaluated, where the default is `Main`. The module relative to `Main` and does not depend on the current module.

```
@ref{...}
```

Cross-reference link to a docstring. Uses the same syntax as `:docs`, but only a single object may appear in each `:ref`. If a `:ref` does not find a `:anchor` during expansion an error is thrown.

```
@anchor{...}
```

Related to `:ref`. `:anchor`s are the targets that `:ref` looks for during documentation expansion. `:anchor`s must each refer to unique objects. An error is thrown when multiple `:anchor`s correspond to the same object.

```
@break{}
```

Adds a paragraph break in the final output.

```
@code{...}
```

Run Julia code and display the final result. All code is run in a fresh `Module` to avoid interference between different `:code` directives.

```
@repl{...}
```

Simulate a Julia REPL environment. Each complete expression is presented with a `julia>` before and it's result afterwards in the final output. ending an expression with `;` will suppress the output.

See also: [`define`](internals.md#Docile.DocTree.define).
