<!-- Generated by Docile.jl | 2015-09-15T18:48:03 -->

# Internals

## Index

**DocTree**

  * [`Chunk`](#Docile.DocTree.Chunk)
  * [`Node`](#Docile.DocTree.Node)
  * [`exprnode`](#Docile.DocTree.exprnode)
  * [`File`](#Docile.DocTree.File)
  * [`Root`](#Docile.DocTree.Root)
  * [`checksizes`](#Docile.DocTree.checksizes)
  * [`expand!`](#Docile.DocTree.expand!)
  * [`define`](#Docile.DocTree.define)
  * [`getdocs`](#Docile.DocTree.getdocs)
  * [`extractdocs`](#Docile.DocTree.extractdocs)

**Utilities**

  * [`Str`](#Docile.Utilities.Str)
  * [`tryget`](#Docile.Utilities.tryget)
  * [`exports`](#Docile.Utilities.exports)
  * [`moduleheader`](#Docile.Utilities.moduleheader)
  * [`@get`](#Docile.Utilities.@get)
  * [`@S_str`](#Docile.Utilities.@S_str)
  * [`submodules`](#Docile.Utilities.submodules)
  * [`files`](#Docile.Utilities.files)
  * [`evalblock`](#Docile.Utilities.evalblock)
  * [`parseblock`](#Docile.Utilities.parseblock)
  * [`@object`](#Docile.Utilities.@object)
  * [`getobject`](#Docile.Utilities.getobject)
  * [`getmodule`](#Docile.Utilities.getmodule)
  * [`concat!`](#Docile.Utilities.concat!)
  * [`msg`](#Docile.Utilities.msg)

**Parser**

  * [`parsedocs`](#Docile.Parser.parsedocs)
  * [`getname`](#Docile.Parser.getname)
  * [`getbracket`](#Docile.Parser.getbracket)
  * [`trypeek`](#Docile.Parser.trypeek)
  * [`trywrite!`](#Docile.Parser.trywrite!)

## Details

### `Docile.DocTree`

<a name="Docile.DocTree.DocTree"></a>

```
Docile.DocTree :: Module
```

Abstract representation of a documentation tree.

<a name="Docile.DocTree.Chunk"></a>

```
Chunk
```

Chunks store a fragment of documentation from either a docstring or file together with a name that describes how `Docile` handles the `Chunk`.

The field `.done` tells `expand!` whether the chunk should be processed or not. `true` for process and `false` for skip.

```
Chunk(tuple)
```

Constructor that converts the raw tuples produced by `Parser.parsedocs` into `Chunk`s.

<a name="Docile.DocTree.Node"></a>

```
Node
```

Stores a collection of `Chunk`s together with a `Module` reference that is used to resolve cross-references and anchors.

```
Node(str :: Str)
```

Constructor that converts a string into a `Node` object by extacting all `Chunks` from the given string `str`.

<a name="Docile.DocTree.exprnode"></a>

```
exprnode(str)
```

Returns an expression containing a `Node` constructor call for use by `Hooks.directives`.

<a name="Docile.DocTree.File"></a>

```
File
```

Represents a source file, it's contents in the form of `Node`s and the destination it will be written to.

<a name="Docile.DocTree.Root"></a>

```
Root
```

The root node in a documentation tree, storing all `File` objects, a cross-reference dict, and the output mimetype the the files will be written as.

```
Root(mapping, mime)
```

Constructor that takes a vector of `(source, destination)` tuples representing files and builds `File` objects to represent them.

<a name="Docile.DocTree.checksizes"></a>

```
checksizes(root, current)
```

Have any of the files expanded during the previous `expand!` call? `current` is a vector of `Chunk` array lengths.

<a name="Docile.DocTree.expand!"></a>

```
expand!(root :: Root)
```

Expand the doctree until it stops expanding or the iteration limit is reached.

<a name="Docile.DocTree.define"></a>

```
define(f, n)
```

User-extensible directive system hook. Adds handling of user-defined directives.

```julia
Docile.DocTree.define(:custom) do root, file, node, chunk
    # ...
    chunk
end
```

`define`s should return either a single `Chunk`, the original one or a modified one, or a vector of `Chunk`s.

<a name="Docile.DocTree.getdocs"></a>

```
getdocs(mod, expr)
```

Returns all documentation for an expression `expr` evaluated in module `mod` as a vector of `Node`s.

<a name="Docile.DocTree.extractdocs"></a>

```
extractdocs(node, doc, str)
```

Change the module evaluating `Module` and add an `:anchor` directive for the docstring `doc`. Revert back the the orignal `Module` after the documentation has been spliced in.

### `Docile.Utilities`

<a name="Docile.Utilities.Str"></a>

```
Str
```

Shorthand for `AbstractString`.

<a name="Docile.Utilities.tryget"></a>

```
tryget(mod, field, default)
```

Returns the value bound to `field` in module `mod` or `default` if not found.

<a name="Docile.Utilities.exports"></a>

```
exports()
```

Markdown formatted string containg a list of all exported symbols in a module.

<a name="Docile.Utilities.moduleheader"></a>

```
moduleheader()
```

Returns a string containing a markdown formatted `Module` docstring header.

<a name="Docile.Utilities.@get"></a>

```
@get(where, what, default)
```

Do `default` if `what` is not defined in `where` otherwise get `what` from `where`.

<a name="Docile.Utilities.@S_str"></a>

```
@S_str(text)
```

Shorthand syntax for defining symbols that are not valid identifiers.

<a name="Docile.Utilities.submodules"></a>

```
submodules(mod)
```

Returns a set of all submodules of `Module` `mod`.

<a name="Docile.Utilities.files"></a>

```
files(cond, root)
```

Returns a set of all files from `root` that match `cond`.

<a name="Docile.Utilities.evalblock"></a>

```
evalblock(modname, block)
```

Evaluate the string `block` within the module `modname` and return the final value.

<a name="Docile.Utilities.parseblock"></a>

```
parseblock(block)
```

Returns a vector of all complete expressions and their original substrings found in `block`.

<a name="Docile.Utilities.@object"></a>

```
@object(ex)
```

Return the object/binding that an expression represents.

<a name="Docile.Utilities.getobject"></a>

```
getobject(mod, text)
```

Try to get the object found in `text` within module `mod`. Returns a `Nullable` if it fails.

<a name="Docile.Utilities.getmodule"></a>

```
getmodule(mod, text)
```

Try to get the `Module` object in `text`. Returns a `Nullable{Module}` if it fails.

<a name="Docile.Utilities.concat!"></a>

```
concat!(xs, x)
```

Append or push depending on the object being added to a vector. For flattening nested lists.

<a name="Docile.Utilities.msg"></a>

```
msg(text, cond)
```

Conditionally display a message.

### `Docile.Parser`

<a name="Docile.Parser.parsedocs"></a>

```
parsedocs(text)
```

Parse a string `text` and return a vector of tuples representing the raw directive syntax.

<a name="Docile.Parser.getname"></a>

```
getname(buf)
```

Check for `@<name>{` syntax from the start of the buffer `buf`. Returns the `<name>` as a symbol if found. Also returns `true` or `false` to signal whether directive has been found.

<a name="Docile.Parser.getbracket"></a>

```
getbracket(buf)
```

Returns the contents of a matching `{...}` pair as a string. Throws a `ParseError` when the brackets do not match.

<a name="Docile.Parser.trypeek"></a>

```
trypeek(buffer, char)
```

Check if the next character in a buffer is `char`.

<a name="Docile.Parser.trywrite!"></a>

```
trywrite!(out, buf)
```

Push the contents of `buf` to `out` if there is anything written to it.
